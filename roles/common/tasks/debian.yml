---

- name: Install software updates
  ansible.builtin.apt:
    update_cache: true
    install_recommends: true
    upgrade: dist
  register: result
  until: result is succeeded
  retries: 5
  delay: 10

- name: Check if reboot is required
  ansible.builtin.shell: >
    if [[ -e /var/run/reboot-required ]]; then echo "required"; else echo "no"; fi
  args:
    executable: /bin/bash
  register: reboot_required
  changed_when: false

- name: Ensure reboot if required. Using defaults
  ansible.builtin.reboot:
  when: reboot_required is defined and reboot_required.stdout == 'required'

- name: Wait until the server becomes ready...
  ansible.builtin.wait_for_connection:
    delay: 20
    timeout: 320
  when: reboot_required is defined and reboot_required.stdout == 'required'

- name: Include unattended upgrades configuration
  import_tasks: unattended-upgrades.yml

- name: Disable MOTD on login and SSHD
  ansible.builtin.replace: dest="{{ item.file }}" regexp="{{ item.regexp }}" replace="{{ item.line }}"
  with_items:
    - {regexp: '^session.*optional.*pam_motd.so.*', line: '# MOTD DISABLED', file: '/etc/pam.d/login'}
    - {regexp: '^session.*optional.*pam_motd.so.*', line: '# MOTD DISABLED', file: '/etc/pam.d/sshd'}

- name: Ensure fallback resolvers are set
  ansible.builtin.ini_file:
    path: /etc/systemd/resolved.conf
    mode: 0644
    section: Resolve
    option: FallbackDNS
    value: "{{ dns_servers.ipv4 | join(' ') }}"
  notify:
    - restart systemd-resolved

- name: Loopback for services configured
  ansible.builtin.template:
    src: 10-wgvps-lo100.network.j2
    dest: /etc/systemd/network/10-wgvps-lo100.network
    mode: 0644
  notify:
    - restart systemd-networkd

- name: Ensure systemd services enabled and started
  ansible.builtin.systemd:
    name: "{{ item }}"
    state: started
    enabled: true
    daemon_reload: true
  with_items:
    - systemd-networkd
    - systemd-resolved
    - unattended-upgrades

- name: Force all notified handlers to run at this point, not waiting for normal sync points
  ansible.builtin.meta: flush_handlers

- name: Check apparmor support
  ansible.builtin.command: apparmor_status
  # ignore_errors: yes
  changed_when: false
  register: apparmor_status

- name: Set fact if apparmor enabled
  ansible.builtin.set_fact:
    apparmor_enabled: true
  when: '"profiles are in enforce mode" in apparmor_status.stdout'

# - name: Gather additional facts
#   import_tasks: facts.yml
# p12_export_password
# CA_password
- name: Set ip_subject_alt_name as a fact
  ansible.builtin.set_fact:
    ip_subject_alt_name: "{{ ansible_default_ipv4.address }}"
- name: Set IPv6 support as a fact
  ansible.builtin.set_fact:
    ipv6_support: "{% if ansible_default_ipv6['gateway'] is defined %}true{% else %}false{% endif %}"
- name: Check size of MTU
  ansible.builtin.set_fact:
    reduce_mtu: "{{ 1500 - ansible_default_ipv4['mtu']|int if reduce_mtu|int == 0 and ansible_default_ipv4['mtu']|int < 1500 else reduce_mtu|int }}"

# Apparmor is installed and active by default on debian 11, at least on digital ocean
# Apparmor-utilities provides utilities that operate on AppArmor profiles.
# Profiles can be created, updated, enforced, set to complain mode, and disabled with tools such as aa-genprof, aa-enforce, aa-complain and aa-disabled.
# Installs apparmor-utils python3-apparmor python3-libapparmor
#
# The libuuid library generates and parses 128-bit Universally Unique IDs (UUIDs).
# A UUID is an identifier that is unique within the space of all such identifiers across both space and time.
# It can be used for multiple purposes, from tagging objects with an extremely short lifetime to reliably identifying very persistent objects across a network.
# This package contains the uuidgen program and the uuidd daemon.
# Already installed on debian 11
#
# Coreutils is already installed
# This package contains the basic file, shell and text manipulation utilities which are expected to exist on every operating system
#
# GnuPG is GNU's tool for secure communication and data storage.
# It can be used to encrypt data and to create digital signatures. It includes an advanced key management facility and is compliant with
# the proposed OpenPGP Internet standard as described in RFC4880.
# Already installled
#
# Openssl already installed
# This package is part of the OpenSSL project's implementation of the SSL and TLS cryptographic protocols for secure communication over the Internet.
#
# Control Groups (cgroups) provide a mechanism for aggregating/partitioning sets of tasks, and all their future children,
# into hierarchical groups with specialized behaviour.
# libcgroup allows one to manipulate, control, administrate and monitor cgroups and the associated controllers.
# This package contains the command-line tools.
# Installs cgroup-tools libcgroup1
#
# Algo required screen instead of tmux and iptables-persistent instead of nftables
#
- name: Set OS specific facts
  ansible.builtin.set_fact:
    tools:
      - git
      - nftables
      - tmux
      - apparmor-utils
      - coreutils
      - uuid-runtime
      - cgroup-tools
      - openssl
      - gnupg2
      - htop
    sysctl:
      - item: net.ipv4.ip_forward
        value: 1
      - item: net.ipv4.conf.all.forwarding
        value: 1
      - item: "{{ 'net.ipv6.conf.all.forwarding' if ipv6_support else none }}"
        value: 1

- name: Ensure tools are installed
  ansible.builtin.apt:
    name: "{{ tools|default([]) }}"
    state: present
    update_cache: true

# - name: Configure the alternative ingress ip
#   include_tasks: aip/main.yml
#   when: alternative_ingress_ip

- include_tasks: nftables.yml
  tags: nftables
